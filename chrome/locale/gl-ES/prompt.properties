# -*- coding: utf-8 -*-
sendaround=Enviar ó redor de
entervalid=Insire unha data válida arriba
sendwithfunction=Enviar de acordo á función “%1$S”
sendspecifyfunction=Seleccionar unha función do menú superior
January=Xaneiro
February=Febreiro
March=Marzo
April=Abril
May=Maio
June=Xuño
July=Xullo
August=Agosto
September=Setembro
October=Outubro
November=Novembro
December=Decembro
OptionShortcutAlertTitle=Valor de atallo non válido
OptionShortcutAlertText=O atallo %1$S ten o valor non válido “%2$S”
SendingUnsentError={NAME}: Erro ó enviar mensaxes pendentes. A Bandexa de Saída pode estar corrompida e as súas mensaxes programadas poden non terse enviado. Vexa https://blog.kamens.us/send-later/#outbox.
CopyUnsentError={NAME}: Erro ó copiar a mensaxe programada da Bandexa de saída para o envío (código %x). {NAME} foi desactivado! Vexa https://blog.kamens.us/send-later/#outbox-copy-failure.
CopyRecurError={NAME}: Erro ó copiar a mensaxe recorrente para o cartafol de Borradores (code %x). {NAME} foi desactivado! Vexa https://blog.kamens.us/send-later/#drafts-copy-failure.
CorruptFolderError={NAME}: O cartafol %S pode estar corrompido. Por favor abra as súas propiedades e amáñeo. Vexa https://blog.kamens.us/send-later/#corrupt-drafts-error.
MessageResendError={NAME}: Tenta enviar unha mensaxe xa enviada?! A súa Bandexa de Saída ou o cartafol de Borradores %S probablemente estean danados. Por favor, amáñeos coma se describe en https://blog.kamens.us/send-later/#corrupt-outbox.
minutely=cada minuto
daily=a diario
weekly=semanalmente
monthly=mensualmente
yearly=anualmente
plural_minutely=minutos
plural_daily=días
plural_weekly=semanas
plural_monthly=meses
plural_yearly=anos
every_minutely=cada %S minutos
every_daily=cada %S días
every_weekly=cada %S semanas
every_monthly=cada %S meses
every_yearly=cada %S anos
everyempty=semana do mes
everymonthly=%1$S %2$S do mes
everymonthly_short=%1$S %2$S
betw_times=entre as %S:%S e as %S:%S
only_on_days=o %S
day0=Domingo
day1=Luns
day2=Martes
day3=Mércores
day4=Xoves
day5=Venres
day6=Sábado
ord1=1º
ord2=2º
ord3=3º
ord4=4º
ord5=5º
draftSaveWarning=AVISO: Pra Previr que a mensaxe sexa enviada polo {NAME} mentres o edita, a sua data de envío foi cancelada. Por favor defina unha nova data cando remate a súa edición.
AreYouSure=Estás seguro?
OutboxConfirmMessage=Clicando en "Colocar na Bandexa de saída" coloca a mensaxe na Bandexa de saída inmediatamente. Isto NON programa a mensaxe para ser enviada nun momento específico. Para iso, faga click no botón "Enviar ó redor de" no recadro verde despois de introducir un tempo de envío válido. Está seguro de querer colocar a mensaxe na Bandexa de saída agora?
SendNowConfirmMessage=Clicando en "Enviar agora" envía a mensaxe inmediatamente. Isto NON programa a mensaxe para ser enviada nun momento específico. Para iso, prema no botón "Enviar" na caixa verde despois de introducir un tempo de envío válido. Está seguro de querer enviar a mensaxe agora?
ConfirmAgain=Mostre este aviso a próxima vez
ScheduledMessagesWarningTitle=Aviso de mensaxes programadas
ScheduledMessagesWarningQuitRequested=Hai mensaxes programadas para ser enviados. {NAME} so pode enviar mensaxes cando %S está en funcionamento. ¿Está seguro de que quere sair?
ScheduledMessagesWarningQuit={NAME} so pode enviar mensaxes cando %S está en funcionamento. Por favor, ¡lembre volver a inicialo antes do intre programado de envío das súas mensaxes!
EnigmailIncompatTitle=Problema de compatibilidade do {NAME} / Enigmail
EnigmailIncompatText=A versión instalada do Enigmail é incompatible con {NAME}, por iso a programación de mensaxes con o {NAME} foi desactivada. Por favor contacte co responsable do {NAME} (jik@kamens.us) para obter asistencia.
TimeMismatchConfirmTitle=Incoherencia na hora de envío / restrición
TimeMismatchConfirmBody=A hora de envío %1$S non entra dentro das restricións horarias especificadas. Clique en Cancelar para editar a súa hora de envío ou restricións, ou en OK para axusta-la hora de envío automaticamente a %2$S.
endTimeWarningTitle=Restrición de horario de mensaxe non válida
endTimeWarningBody=Ao especificar unha restrición de horario de mensaxe, a hora final non pode ser mais cedo que a hora inicial. Por favor axuste a sua restrición de horario ou desactívea.
missingDaysWarningTitle=Restrición de data non válida
missingDaysWarningBody=Activou unha restrición de data de mensaxe sen especificar ningún día. Por favor desactive a restrición de data ou especifique polo menos un día para o envío.
InvalidArgsTitle=Argumentos de función inválidos
InvalidArgsBody=Os argumentos da función non son válidos. Especifique unha lista JavaScript, sen corchetes.
BlockedLateMessage=A mensaxe co asunto “%1$S” no cartafol de Borradores %2$S foi programado para ser enviado fai máis de %3$S minutos, así que o envío foi bloqueado. Debe editar o borrador, e ou ben envialo manualmente ou voltar a programar o envío. Tamén pode desactivar o axuste “Non enviar mensaxes con máis de N minutos de atraso” para deixar de bloquear o envío de mensaxes con atraso.
EditorReadMeCode=// ¡Benvido ó editor de funcións de {NAME}!\n// \n// O editor permítelle crear funcións JavaScript que implementan\n// lóxicas complexas de programación de envío de mensaxes que se\n// poden asociar con botóns de atallo ou seleccionarse no cadro de\n// diálogo de {NAME}.\n// \n// Coma pode ver enriba, cando se chama a unha función de programación\n// de envío, proporciónanselle tres argumentos:\n// \n// * "specname" (nobre da especificación) necesitase se quere\n//   que esta función sexa recorrente (vexa abaixo)\n// * "prev" é a anterior hora de envío programada, se esta é unha\n//   invocación recorrente\n// * "args" son os argumentos extra devoltos pola anterior\n//   invocación da función, se esta é unha invocación recorrente\n// \n// O seu código precisa establecer as variables "next" (seguinte\n// envío), "nextspec"(seguinte especificación), e "nextargs"\n// (seguintes argumentos) como segue:\n//\n// * "next" é ou ben o número de minutos a futuro ou un obxecto de\n//  data indicando cando se debe enviar a mensaxe.\n// \n// * "nextspec" é unha especificación de recorrencia, se pretende\n//   que sexa unha mensaxe recorrente. Se non establece isto, entón a\n//   mensaxe so se enviará unha vez (vexa\n//   https://blog.kamens.us/send-later/#dynamic-recurrence).  Nota: Se\n//   quere que a súa función sexa chamada de novo por recorrencia, faga\n//   \n//   nextspec = "function " + specname;\n//   \n// * "nextargs" é unha matriz de argumentos que quere que sexa pasada\n//   na próxima invocación da función coma "args".\n// \n// Mentres está traballando na súa función, pode probala enchendo\n// os valores para "prev" e "args" nos recadros de texto de\n// abaixo, e logo facendo clic en "Executar" para executar a\n// función e ver os resultados.\n// \n// Hai dúas funcións de exemplo pre-configuradas, "BusinessHours"\n// (horario comercial) e "DaysInARow" (días seguidos), que pode\n// revisar e cas que pode practicar para aprender máis.\n// \n// Esta función "ReadMeFirst" (léame primeiro) so fai que a mensaxe\n// sexa enviada aproximadamente agora, mediante a seguinte liña:\n\nnext = new Date();
EditorReadMeHelp=Calquera texto que poña aquí amosarase coma unha suxestión emerxente cando se sitúe sobre o nome da función no menú. Pode usar isto para documentar o que fai a función e qué argumentos acepta.
_BusinessHoursCode=/ Defaults\nvar workDays = [1, 2, 3, 4, 5]; // Seg - Sex; Sun == 0, Sat == 6\nvar workStart = [8, 30]; // Inicio do dia útil en [H, M]\nvar workEnd = [17, 30]; // Fin do dia útil en [H, M]\nif (args && args[0])\n    workDays = args[0];\nif (args && args[1])\n    workStart = args[1];\nif (args && args[2])\n    workEnd = args[2];\nif (prev)\n    // Non se agarda para o uso normal, pero usado coma tempo actual para testeo.\n    next = new Date(prev);\nelse\n    next = new Date();\n// Se é despois do horario laboral ou nun día non laborable, \n// avanzar ata a primeira hora útil do dia seguinte.\n\nwhile ((next.getHours() > workEnd[0]) ||\n       (next.getHours() == workEnd[0] && next.getMinutes() > workEnd[1]) ||\n       (workDays.indexOf(next.getDay()) == -1)) {\n    next.setDate(next.getDate() + 1);\n    next.setHours(workStart[0]);\n    next.setMinutes(workStart[1]);\n}\n// Se a hora actual é antes do inicio do horario laboral, mover ó inicio do horario laboral. \nif ((next.getHours() < workStart[0]) ||\n    (next.getHours() == workStart[0] && next.getMinutes() < workStart[1])) {\n    next.setHours(workStart[0]);\n    next.setMinutes(workStart[1]);\n}
BusinessHoursHelp=Envía a mensaxe agora se aínda é horario comercial, ou ó principio da seguinte xornada laboral. Pode mudar a definición de días laborais (por defecto: Lun - Ven) pasando coma primeiro argumento unha matriz de números correspondentes a tales días, onde 0 é o domingo e 6 o sábado. Pode cambiar as horas de inicio ou fin da xornada laboral (predeterminadas: 8:30 - 17:30) pasando coma segundo ou terceiro argumento unha matriz de [H, M]. Especifique “null” (nulo) para argumentos iniciais que non queira mudar. Por exemplo, “null [9, 0], [17, 0]” cambia as horas de traballo sen mudar os días laborais.
DaysInARowCode=// Enviar a primeira mensaxe agora, mensaxes posteriores unha vez ó día.\nif (! prev)\n    next = new Date();\nelse {\n    var now = new Date();\n    next = new Date(prev); // Copiar o argumento da data de xeito que non sexa modificado.\n    do {\n        next.setDate(next.getDate() + 1);\n    } while (next < now);\n    // ^^^ Non tentar enviar ó pasado, en caso de que o Thunderbird estivese en suspenso no\n    // horario de envío programado.\n}\nif (! args) // Enviar mensaxes tres vecer por defecto.\n    args = [3];\nnextargs = [args[0] - 1];\n// Repetir se aínda non se fixo o número de envíos suficiente.\nif (nextargs[0] > 0)\n    nextspec = "function " + specname;
DaysInARowHelp=Envía a mensaxe agora, e consecutivamente unha vez ó día á mesma hora, ata que teña sido enviada tres veces. Especifique un número coma argumento para cambiar o número total de envíos.
DiscardConfirmTitle=Descartar cambios?
DiscardConfirmBody=Hai cambios sen gardar. ¿Quere descartalos?
UntestedSaveTitle=Gardar función sen comprobala?
UntestedSaveBody=A función non se probou (co botón “Executar”) xa que foi modificada recentemente. Está seguro de que quere gardala ou exportala?
BadSaveTitle=Nome ou código de función non válido
BadSaveBody=Verifique se o nome da función e o código son válidos antes de gardar ou exportar.
ReplacingFunctionTitle=Substituír a función existente?
ReplacingFunctionBody=Xa existe unha función co nome especificado. Está seguro de que quere substituíla?
NoNextValueError=A función non definiu un valor “next” (seguinte envío).
BadNextValueError=O valor "%1$S" de "next" non é un número nin unha data
BadNextArgsError=o valor “%1$S” de “nextargs” non é unha matriz (Array)
FunctionDeleteConfirmBody=Está seguro de que quere borrar esta función? Se está asociada con calquera botón de atallo, deixarán de funcionar; e se hai mensaxes recorrentes usándoa, trala próxima ocasión na que se envíen non se poderán voltar a programar os envíos.
ImportTitle=Escolla o ficheiro a importar
SLJFilterLabel=Ficheiros JSON de {NAME}
ImportError=Erro ao importar
ExportTitle=Escolla un destino para a exportación
RenameFunctionTitle=Renomear a función existente?
RenameFunctionBody=Alterou o nome dunha función existente, “%1$S”. Pretende mudar o nome da función existente ou salvar unha nova función con outro nome?
RenameFunctionRenameButton=Renomear
RenameFunctionNewButton=Novo
FunctionErrorTitle=Erro ó invocar a función dinámica
FunctionErrorBody=Erro ó invocar a función de programación dinámica: “%1$S”
cancel_on_reply=cancelar en caso de resposta
